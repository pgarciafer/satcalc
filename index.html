<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Satellite Calculator Look Angle</title>
  <style>
    :root{font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    body{display:flex;align-items:center;justify-content:center;min-height:100vh;margin:0;background:linear-gradient(180deg,#f8fafc,#eef2ff)}
    .card{background:#ffffff;border-radius:12px;box-shadow:0 10px 30px rgba(2,6,23,0.08);padding:20px;max-width:700px;width:95%;}
    h1{font-size:18px;margin:0 0 16px;color:#0f172a;text-align:center}
    .coords{display:flex;flex-direction:column;gap:12px;margin-top:12px}
    .coord-item{
      display:grid;
      grid-template-columns: minmax(80px,140px) 1fr auto;
      align-items:center;
      gap:8px;
      background:#f8fafc;
      padding:8px 12px;
      border-radius:8px;
    }
    .coord-item label{margin:0;color:#0f172a;font-weight:500;}
    .coord-item input{
      width:100%;min-width:0;text-align:center;border:none;background:transparent;
      font-size:18px;color:#0f172a;outline:none;appearance:textfield;padding:6px 4px;
    }
    .coord-item input:focus{background:#e0f2fe;border-radius:4px;}
    .coord-item input::-webkit-outer-spin-button,
    .coord-item input::-webkit-inner-spin-button { -webkit-appearance:none; margin:0; }
    .coord-item select{
      font-size:16px;padding:6px 8px;border-radius:6px;border:1px solid #cbd5e1;
      background:white;color:#0f172a;min-width:48px;
    }
    .actions{display:flex;gap:8px;margin-top:14px;justify-content:center}
    button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5a4;color:white;cursor:pointer;font-weight:500}
    button.secondary{background:#64748b}
    button.small{padding:4px 8px;font-size:13px}
    .blocking-section{margin-top:12px}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    th,td{text-align:center;padding:6px;border-bottom:1px solid #e2e8f0}
    th{color:#0f172a;font-weight:600}
    td input{width:90px;text-align:center}
    .diagrams{display:flex;flex-wrap:wrap;gap:20px;justify-content:center;margin-top:20px}
    .diagram{display:flex;flex-direction:column;align-items:center}
    canvas{background:white;border-radius:8px;}
    @media (max-width: 600px){
      .diagrams{flex-direction:column;align-items:center}
      canvas{width:100% !important;height:auto !important;max-width:300px}
    }
    @media (min-width: 601px){
      .diagrams{flex-direction:row;justify-content:space-around}
      canvas{width:180px;height:180px}
    }
    #zonesTable td input {
      width: 100%;
      min-width: 0;
      text-align: center;
      border: none;
      background: transparent;
      font-size: 18px;
      color: #0f172a;
      outline: none;
      appearance: textfield;
      padding: 6px 4px;
    }
    #zonesTable td input:focus {
      background: #e0f2fe;
      border-radius: 4px;
    }
    #satRangesList {
      margin-top: 12px;
      font-size: 14px;
      line-height: 1.4;
    }
    .zone-range { margin: 4px 0; }
    .zone-range .color {
      display:inline-block;
      width:12px;
      height:12px;
      border-radius:50%;
      margin-right:6px;
    }
  </style>
</head>
<body>
  <div class="card" role="region" aria-label="Device coordinates">
    <h1>Satellite Calculator Look Angle</h1>

    <div class="coords" aria-live="polite">
      <div class="coord-item">
        <label for="lat">Latitude</label>
        <input id="lat" type="text" inputmode="decimal" value="38.88" />
        <select id="latDir"><option value="N" selected>N</option><option value="S">S</option></select>
      </div>

      <div class="coord-item">
        <label for="lon">Longitude</label>
        <input id="lon" type="text" inputmode="decimal" value="1.40" />
        <select id="lonDir"><option value="E" selected>E</option><option value="W">W</option></select>
      </div>

      <div class="coord-item">
        <label for="satLon">Satellite Longitude</label>
        <input id="satLon" type="text" inputmode="decimal" value="18.00" />
        <select id="satLonDir"><option value="E">E</option><option value="W" selected>W</option></select>
      </div>

      <div class="coord-item">
        <label for="heading">Heading</label>
        <input id="heading" type="text" inputmode="decimal" value="0.00" />
      </div>

      <!-- Blocking Zones -->
      <div class="coord-item" id="blockingZonesSection" style="display:block; grid-template-columns:1fr;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
          <label style="font-weight:600;">Blocking Zones</label>
          <button type="button" id="addBlockBtn">Add Blocking Zone</button>
        </div>
        <table id="zonesTable" style="display:none; width:100%;">
          <thead>
            <tr><th>AZ Start</th><th>AZ Stop</th><th></th></tr>
          </thead>
          <tbody id="zonesBody"></tbody>
        </table>
      </div>
    </div>

    <div class="actions">
      <button id="refreshBtn">Get my location</button>
      <button id="copyBtn" class="secondary" disabled>Copy</button>
    </div>

    <div class="diagrams">
      <div class="diagram">
        <div id="azVal">AZ=</div>
        <div id="elVal">EL=</div>
      </div>
    </div>

    <div class="diagrams">
      <div class="diagram">
        <div id="relVal">REL=</div>
        <div id="blockMsg" style="color:red; font-size:13px; display:none;"></div>
        <canvas id="relCanvas" width="200" height="200"></canvas>
      </div>
    </div>

    <div id="satRangesList"></div>

  <script>
  const relCanvas=document.getElementById("relCanvas");
  const relCtx=relCanvas.getContext('2d');
  const blockMsg=document.getElementById("blockMsg");

  const latEl=document.getElementById('lat'), lonEl=document.getElementById('lon');
  const latDir=document.getElementById('latDir'), lonDir=document.getElementById('lonDir');
  const satLonEl=document.getElementById('satLon'), satLonDir=document.getElementById('satLonDir');
  const headingEl=document.getElementById('heading');
  const refreshBtn=document.getElementById('refreshBtn'), copyBtn=document.getElementById('copyBtn');
  const azVal=document.getElementById('azVal'), elVal=document.getElementById('elVal'), relVal=document.getElementById('relVal');

  const zonesTable=document.getElementById("zonesTable");
  const zonesBody=document.getElementById("zonesBody");
  const addBlockBtn=document.getElementById("addBlockBtn");
  const satRangesList=document.getElementById("satRangesList");

  const zoneColors = [
    "rgba(255, 0, 0, 0.25)",
    "rgba(0, 128, 255, 0.25)",
    "rgba(0, 200, 0, 0.25)",
    "rgba(255, 165, 0, 0.25)",
    "rgba(128, 0, 128, 0.25)",
    "rgba(255, 20, 147, 0.25)"
  ];

  function formatNumber(num) {
    return (Math.round(num * 100) / 100).toString().replace(/\.00$/, "");
  }

  function drawZone(start, stop, isActive, index) {
    let startAZ = (start + 360) % 360;
    let stopAZ  = (stop  + 360) % 360;
    if (stopAZ < startAZ) stopAZ += 360;

    const baseColor = zoneColors[(index - 1) % zoneColors.length];
    const fillColor = isActive ? baseColor.replace("0.25", "0.45") : baseColor;

    relCtx.save();
    relCtx.translate(100, 100);
    relCtx.fillStyle = fillColor;
    relCtx.beginPath();
    relCtx.moveTo(0, 0);
    relCtx.arc(0, 0, 80, (startAZ - 90) * Math.PI / 180, (stopAZ - 90) * Math.PI / 180, false);
    relCtx.closePath();
    relCtx.fill();
    relCtx.restore();
  }

function drawRel(rel) {
  relCtx.clearRect(0, 0, 200, 200);

  if (!vesselImg.complete) {
    vesselImg.onload = () => drawRel(rel);
    return;
  }

  relCtx.save();
  relCtx.translate(100, 100);
  relCtx.drawImage(vesselImg, -110, -110, 220, 220);
  relCtx.restore();

  const results = checkBlockingZones(rel);

  const rows = zonesBody.querySelectorAll("tr");
  rows.forEach((row, idx) => {
    const start = parseFloat(row.cells[0].querySelector("input").value);
    const stop  = parseFloat(row.cells[1].querySelector("input").value);
    if (isNaN(start) || isNaN(stop)) return;
    const isActive = results && results.some(r => r.index === idx + 1);
    drawZone(start, stop, isActive, idx + 1);
  });

  const rad = (rel - 90) * Math.PI / 180;
  relCtx.strokeStyle = results && results.length
    ? zoneColors[(results[0].index - 1) % zoneColors.length].replace("0.25", "1.0")
    : "blue";
  relCtx.lineWidth = 2;
  relCtx.beginPath();
  relCtx.moveTo(100, 100);
  relCtx.lineTo(100 + 70 * Math.cos(rad), 100 + 70 * Math.sin(rad));
  relCtx.stroke();

  if (results && results.length) {
    const msg = results.map(r => `zone ${r.index}`).join(", ");
    const zoneColor = zoneColors[(results[0].index - 1) % zoneColors.length].replace("0.25", "1.0");
    blockMsg.textContent = `Entered in block ${msg}`;
    blockMsg.style.display = "block";
    blockMsg.style.color = zoneColor;
  } else {
    blockMsg.style.display = "none";
  }
}


function checkBlockingZones(rel) {
  const rows = zonesBody.querySelectorAll("tr");
  const matches = [];
  let zoneIndex = 0;

  for (const row of rows) {
    zoneIndex++;
    const start = parseFloat(row.cells[0].querySelector("input").value);
    const stop  = parseFloat(row.cells[1].querySelector("input").value);
    if (isNaN(start) || isNaN(stop)) continue;

    let startAZ = (start + 360) % 360;
    let stopAZ  = (stop + 360) % 360;

    if (startAZ <= stopAZ) {
      if (rel >= startAZ && rel <= stopAZ) {
        matches.push({ index: zoneIndex, start, stop });
      }
    } else {
      if (rel >= startAZ || rel <= stopAZ) {
        matches.push({ index: zoneIndex, start, stop });
      }
    }
  }

  return matches.length ? matches : null;
}


  function createZoneRow(start=0.00, stop=0.00){
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><input type="text" inputmode="decimal" value="${formatNumber(start)}"></td>
      <td><input type="text" inputmode="decimal" value="${formatNumber(stop)}"></td>
      <td><button class="small secondary">Remove</button></td>
    `;
    const startInput = tr.querySelector("td:nth-child(1) input");
    const stopInput  = tr.querySelector("td:nth-child(2) input");
    [startInput, stopInput].forEach(inp => {
      inp.addEventListener("input", updateAll);
      inp.addEventListener("blur", () => {
        let val = (inp.value || "").trim().replace(",", ".");
        let num = parseFloat(val);
        if(isNaN(num)) num = 0;
        if(num < 0) num = 0;
        if(num > 360) num = 360;
        inp.value = formatNumber(num);
        updateAll();
      });
      inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
    });
    tr.querySelector("button").addEventListener("click",()=>{
      tr.remove();
      if(zonesBody.children.length===0) zonesTable.style.display="none";
      updateAll();
    });
    zonesBody.appendChild(tr);
    zonesTable.style.display="table";
    setupKeyboardNavigation();
    updateAll();
  }

  addBlockBtn.addEventListener("click",()=>createZoneRow());

  function normalizeInput(input, max){
    let val = (input.value || "").trim().replace(",", ".");
    if(val === "") return;
    let num = parseFloat(val);
    if(isNaN(num)) return;
    if(num > max) num = max;
    if(num < 0) num = 0;
    input.value = formatNumber(num);
  }

  function getLatLon(){
    const latVal = parseFloat((latEl.value || "").trim().replace(",", ".")) || 0;
    const lonVal = parseFloat((lonEl.value || "").trim().replace(",", ".")) || 0;
    const satLonVal = parseFloat((satLonEl.value || "").trim().replace(",", ".")) || 0;
    const headingVal = parseFloat((headingEl.value || "").trim().replace(",", ".")) || 0;
    const lat = latDir.value === "N" ? latVal : -latVal;
    const lon = lonDir.value === "E" ? lonVal : -lonVal;
    const satLon = satLonDir.value === "E" ? satLonVal : -satLonVal;
    return { lat, lon, satLon, heading: headingVal };
  }

  function calcAzEl(lat,lon,satLon){
    const Re=6378.137,h=35786.0;
    const latR=lat*Math.PI/180, lonR=lon*Math.PI/180, satLonR=satLon*Math.PI/180;
    const xObs=Re*Math.cos(latR)*Math.cos(lonR), yObs=Re*Math.cos(latR)*Math.sin(lonR), zObs=Re*Math.sin(latR);
    const xSat=(Re+h)*Math.cos(satLonR), ySat=(Re+h)*Math.sin(satLonR), zSat=0;
    const dx=xSat-xObs, dy=ySat-yObs, dz=zSat-zObs;
    const e=-Math.sin(lonR)*dx+Math.cos(lonR)*dy;
    const n=-Math.sin(latR)*Math.cos(lonR)*dx -Math.sin(latR)*Math.sin(lonR)*dy +Math.cos(latR)*dz;
    const u=Math.cos(latR)*Math.cos(lonR)*dx +Math.cos(latR)*Math.sin(lonR)*dy +Math.sin(latR)*dz;
    let az=Math.atan2(e,n)*180/Math.PI; if(az<0)az+=360;
    const el=Math.atan2(u,Math.sqrt(e*e+n*n))*180/Math.PI;
    return {az,el};
  }

  const vesselImg=new Image();
  vesselImg.src="https://pgarciafer.github.io/satcalc/IMG_0585.PNG";

function updateAll(){
  const {lat,lon,satLon,heading}=getLatLon();
  const {az,el}=calcAzEl(lat,lon,satLon);

  azVal.textContent = 'AZ=' + formatNumber(az);

  if (el < 0) {
    elVal.innerHTML = `<span style="color:red">EL=${formatNumber(el)} (Out of Range)</span>`;
  } else {
    elVal.textContent = 'EL=' + formatNumber(el);
  }

  const rel = ((az - heading) + 360) % 360;
  relVal.textContent = 'REL=' + formatNumber(rel);

  drawRel(rel);
  copyBtn.disabled = false;
  computeSatRangesAndRender();
}


  async function getAndShowLocation(){
    if(!('geolocation' in navigator)){ alert("Geolocation not supported."); return; }
    const opts={enableHighAccuracy:true,maximumAge:0,timeout:20000};
    return new Promise(resolve=>{
      navigator.geolocation.getCurrentPosition(pos=>{
        const c=pos.coords;
        latEl.value=formatNumber(Math.abs(c.latitude));
        latDir.value=c.latitude>=0?"N":"S";
        lonEl.value=formatNumber(Math.abs(c.longitude));
        lonDir.value=c.longitude>=0?"E":"W";
        updateAll();
        resolve();
      },err=>{alert('Location error: '+err.message);resolve();},opts);
    });
  }

  refreshBtn.addEventListener("click",()=>getAndShowLocation());
  copyBtn.addEventListener("click",()=>{
    const {lat,lon,satLon,heading}=getLatLon();
    navigator.clipboard.writeText(
      `Lat=${lat} Lon=${lon} SatLon=${satLon} Heading=${heading}`
    ).then(()=>{copyBtn.textContent="Copied!";setTimeout(()=>copyBtn.textContent="Copy",1000)});
  });

  [latEl,lonEl,satLonEl,headingEl].forEach(inp=>{
    inp.addEventListener("blur",()=>{
      normalizeInput(inp,180);
      if(inp===headingEl) normalizeInput(inp,360);
      updateAll();
    });
    inp.addEventListener("input",updateAll);
    inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
  });
  [latDir,lonDir,satLonDir].forEach(sel=>sel.addEventListener("change",updateAll));

  // === SATELLITE RANGE CALCULATION ===
function computeSatRangesForZone(startAZ, stopAZ, lat, lon, heading, step = 1) {
  // normalize azimuth window to [0,360)
  const start = (startAZ + 360) % 360;
  const stop  = (stopAZ + 360) % 360;
  const segments = [];
  let inside = false;
  let segStart = null;

  // integer loop to avoid floating accumulation drift
  const nSteps = Math.round((360 / step));
  for (let i = 0; i <= nSteps; i++) {
    // compute satLon exactly from index
    const satLon = -180 + i * step;
    const { az, el } = calcAzEl(lat, lon, satLon);

    // skip below-horizon satellites (EL < 0 are out of range)
    if (el < 0) {
      if (inside) {
        // we left a visible segment because satellite dropped below horizon.
        // do a small interpolation to estimate more accurate end boundary
        const endEstimate = refineBoundary(segStart, satLon - step, lat, lon, heading, start, stop, step);
        segments.push([segStart, endEstimate]);
        inside = false;
        segStart = null;
      }
      continue;
    }

    const rel = ((az - heading) + 360) % 360;
    let inZone = false;
    if (start <= stop) {
      inZone = (rel >= start && rel <= stop);
    } else {
      inZone = (rel >= start || rel <= stop);
    }

    if (inZone && !inside) {
      // entering a segment: refine entry boundary
      const entry = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step, true);
      segStart = entry;
      inside = true;
    } else if (!inZone && inside) {
      // leaving a segment: refine exit boundary
      const exit = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step);
      segments.push([segStart, exit]);
      inside = false;
      segStart = null;
    }
  }

  // if still inside at the end of sweep, close at +180
  if (inside) {
    segments.push([segStart, 180]);
  }

  console.debug('computeSatRangesForZone', { startAZ, stopAZ, segments });
  return segments;
}

// Helper: refine boundary between satLonA and satLonB
// If findEntry===true we return the earliest satLon within that small interval that produces inZone true.
// Otherwise return the latest satLon within the interval that produces inZone true.
function refineBoundary(a, b, lat, lon, heading, start, stop, coarseStep, findEntry=false) {
  // clamp
  if (a < -180) a = -180;
  if (b > 180) b = 180;
  const subSteps = 10;
  let best = findEntry ? b : a;
  for (let k = 0; k <= subSteps; k++) {
    const t = k / subSteps;
    const satLon = a + (b - a) * t;
    const { az, el } = calcAzEl(lat, lon, satLon);
    if (el < 0) continue;
    const rel = ((az - heading) + 360) % 360;
    let inZone = false;
    if (start <= stop) inZone = (rel >= start && rel <= stop);
    else inZone = (rel >= start || rel <= stop);
    if (inZone) {
      if (findEntry) {
        best = Math.min(best, satLon);
      } else {
        best = Math.max(best, satLon);
      }
    }
  }
  return Math.round(best * 100) / 100; // round to 0.01°
}



  function computeSatRangesAndRender(){
    const { lat, lon, heading } = getLatLon();
    const rows = Array.from(zonesBody.querySelectorAll('tr'));
    if(rows.length === 0){
      satRangesList.innerHTML = "<i>(no blocking zones)</i>";
      return;
    }
    const sampleStep = 0.5;
    const outPieces = [];

    rows.forEach((row, idx) => {
      const start = parseFloat(row.cells[0].querySelector("input").value);
      const stop  = parseFloat(row.cells[1].querySelector("input").value);
      if(isNaN(start) || isNaN(stop)) return;

      let ranges = computeSatRangesForZone(start, stop, lat, lon, heading, sampleStep);

      const west = [], east = [];
      ranges.forEach(([a,b])=>{
        // convert segment endpoints to [-180,180]
        let A = ((a+540)%360)-180;
        let B = ((b+540)%360)-180;
        // ensure A <= B for this segment (segments from computeSatRangesForZone won't wrap across >180)
        if(A > B){ const tmp = A; A = B; B = tmp; }

        if(B <= 0) {
          // both points west (negative longitudes). convert to positive west degrees 0..180
          const lo = Math.abs(B); // smaller magnitude (closer to Greenwich)
          const hi = Math.abs(A); // larger magnitude (further west)
          west.push([lo, hi]);
        } else if (A >= 0) {
          // both points east
          east.push([A, B]);
        } else {
          // crosses Greenwich (A < 0 < B) -> split into two ordered parts:
          // west part: |A| .. 180 (in °W), east part: 0 .. B (in °E)
          west.push([Math.abs(A), 180]);
          east.push([0, B]);
        }
      });

      // merge helper (merge overlapping/adjacent intervals)
      function mergeIntervals(list){
        if(list.length<=1) return list;
        list.sort((a,b)=>a[0]-b[0]);
        const merged=[list[0].slice()];
        for(let i=1;i<list.length;i++){
          const [s,e]=list[i];
          const last=merged[merged.length-1];
          if(s <= last[1] + 0.5){ last[1]=Math.max(last[1],e);} 
          else merged.push([s,e]);
        }
        return merged;
      }

      const mergedWest = mergeIntervals(west);
      const mergedEast = mergeIntervals(east);

      const parts = [];

      // format west: always 0W -> 180W, smaller -> larger (e.g., 11.5°W to 26°W)
      mergedWest.forEach(([lo,hi])=>{
        // ensure numeric order lo <= hi
        if(hi < lo) { const t = lo; lo = hi; hi = t; }
        parts.push(`${formatNumber(lo)}°W to ${formatNumber(hi)}°W`);
      });

      // format east: always 0E -> 180E, smaller -> larger
      mergedEast.forEach(([lo,hi])=>{
        if(hi < lo) { const t = lo; lo = hi; hi = t; }
        parts.push(`${formatNumber(lo)}°E to ${formatNumber(hi)}°E`);
      });

      if(parts.length===0){
        outPieces.push(`<div class="zone-range"><span class="color" style="background:${zoneColors[idx % zoneColors.length].replace("0.25","1.0")}"></span> Zone ${idx+1}: — no sat lon produces REL inside this zone</div>`);
      } else {
        outPieces.push(`<div class="zone-range"><span class="color" style="background:${zoneColors[idx % zoneColors.length].replace("0.25","1.0")}"></span> Zone ${idx+1}: ${parts.join(', ')}</div>`);
      }
    });

    satRangesList.innerHTML = outPieces.join('');
  }

  // Keyboard navigation setup
  function setupKeyboardNavigation() {
    const focusable = Array.from(
      document.querySelectorAll("input, select")
    );
    focusable.forEach((el, idx) => {
      el.addEventListener("keydown", (e) => {
        let newIndex = null;
        if (e.key === "Enter") {
          e.preventDefault();
          newIndex = e.shiftKey ? idx - 1 : idx + 1;
        }
        if (e.key === "ArrowRight" || e.key === "ArrowDown") {
          newIndex = idx + 1;
        }
        if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
          newIndex = idx - 1;
        }
        if (newIndex !== null) {
          if (newIndex < 0) newIndex = focusable.length - 1;
          if (newIndex >= focusable.length) newIndex = 0;
          focusable[newIndex].focus();
        }
      });
    });
  }

  window.addEventListener('DOMContentLoaded',()=>{
    setupKeyboardNavigation();
    updateAll();
  });
  </script>
  </div>
</body>
</html>
