<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Satellite Look Angle Calculator</title>
  <style>
    :root{font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    body{display:flex;align-items:center;justify-content:center;min-height:100vh;margin:0;background:linear-gradient(180deg,#f8fafc,#eef2ff)}
    .card {
        background:#ffffff;
        border-radius:12px;
        box-shadow:0 10px 30px rgba(2,6,23,0.08);
        padding:20px;
        max-width:800px;   /* ⬅ increased so content fits A4 */
        width:100%;        /* ⬅ use full width for export */
        margin:auto;       /* ⬅ center the card */
      }

    h1{font-size:18px;margin:0 0 16px;color:#0f172a;text-align:center}
    .coords{display:flex;flex-direction:column;gap:12px;margin-top:12px}
    .coord-item{
      display:grid;
      grid-template-columns: minmax(60px,100px) 1fr auto;
      align-items:center;
      gap:5px;
      background:#f8fafc;
      padding:5px 11px;
      border-radius:8px;
    }
    .coord-item label{margin:0;color:#0f172a;font-weight:500;}
    .coord-item input{
      width:100%;min-width:0;text-align:center;border:none;background:transparent;
      font-size:15px;color:#0f172a;outline:none;appearance:textfield;padding:4px 4px;
    }
    .coord-item input:focus{background:#e0f2fe;border-radius:4px;}
    .coord-item input::-webkit-outer-spin-button,
    .coord-item input::-webkit-inner-spin-button { -webkit-appearance:none; margin:0; }
    .coord-item select{
      font-size:13px;padding:4px 4px;border-radius:6px;border:1px solid #cbd5e1;
      background:white;color:#0f172a;min-width:48px;
    }
    .actions{display:flex;gap:8px;margin-top:14px;justify-content:center}
    button{padding:8px 12px;border-radius:8px;border:0;background:#0ea5a4;color:white;cursor:pointer;font-weight:500}
    button.secondary{background:#64748b}
    button.small{padding:4px 8px;font-size:13px}
    .blocking-section{margin-top:12px}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    th,td{text-align:center;padding:6px;border-bottom:1px solid #e2e8f0}
    th{color:#0f172a;font-weight:600}
    td input{width:90px;text-align:center}
    .diagrams{display:flex;flex-wrap:wrap;gap:20px;justify-content:center;margin-top:20px}
    .diagram{display:flex;flex-direction:column;align-items:center}
    canvas{background:white;border-radius:8px;}
    @media (max-width: 600px){
      .diagrams{flex-direction:column;align-items:center}
      canvas{width:100% !important;height:auto !important;max-width:300px}
    }
    @media (min-width: 601px) {
  .diagrams {
    gap: 10px; /* reduced from 20px */
  }
  canvas {
    width: 150px;
    height: 150px;
  }
    }
    #zonesTable td input {
      width: 100%;
      min-width: 0;
      text-align: center;
      border: none;
      background: transparent;
      font-size: 10px;
      color: #0f172a;
      outline: none;
      appearance: textfield;
      padding: 3px 3px;
    }
    #zonesTable td input:focus {
      background: #e0f2fe;
      border-radius: 4px;
    }
    #satRangesList {
      margin-top: 12px;
      font-size: 14px;
      line-height: 1.4;
    }
    .zone-range { margin: 4px 0; }
    .zone-range .color {
      display:inline-block;
      width:12px;
      height:12px;
      border-radius:50%;
      margin-right:6px;
    }
    
    #elGraph {
  width: 70%;        /* take full width of parent */
  max-width: 900px;   /* cap on big screens */
  height: auto;       /* keep aspect ratio */
  aspect-ratio: 2 / 1; /* keeps it wide */
}
    
  </style>
</head>
<body>
  <div class="card" role="region" aria-label="Device coordinates">
    <h1>Satellite Look Angle Calculator</h1>

    <div class="coords" aria-live="polite">
      <div class="coord-item">
        <label for="lat">Latitude</label>
        <input id="lat" type="text" inputmode="decimal" value="38.88" />
        <select id="latDir"><option value="N" selected>N</option><option value="S">S</option></select>
      </div>

      <div class="coord-item">
        <label for="lon">Longitude</label>
        <input id="lon" type="text" inputmode="decimal" value="1.40" />
        <select id="lonDir"><option value="E" selected>E</option><option value="W">W</option></select>
      </div>

      <div class="coord-item">
        <label for="satLon">Satellite Longitude</label>
        <input id="satLon" type="text" inputmode="decimal" value="18.00" />
        <select id="satLonDir"><option value="E">E</option><option value="W" selected>W</option></select>
      </div>

      <div class="coord-item">
        <label for="heading">Heading</label>
        <input id="heading" type="text" inputmode="decimal" value="0.00" />
        <div style="width:48px;"></div> </div>


      <div class="coord-item" id="blockingZonesSection" style="display:block; grid-template-columns:1fr;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
  <label style="font-weight:600;">Blockage Zones</label>
  <button type="button" id="addBlockBtn" data-html2canvas-ignore="true">Add Blockage Zone</button>
</div>


        <table id="zonesTable" style="display:none; width:100%;">
          <thead>
            <tr><th>AZ Start</th><th>AZ Stop</th><th></th></tr>
          </thead>
          <tbody id="zonesBody"></tbody>
        </table>
      </div>
    </div>

    <div class="actions" data-html2canvas-ignore="true">
  <button id="refreshBtn">Get my location</button>
  <button id="copyBtn" class="secondary" disabled>Copy values</button>
  <button id="pdfBtn" class="secondary">Generate PDF</button>
</div>

    <div class="diagrams">
      <div class="diagram">
        <div id="azVal">AZ=</div>
        <div id="elVal">EL=</div>
        <div id="visibleRange" style="font-weight:bold; margin-top:4px;"></div>
      </div>
    </div>
    
    
    <div class="diagrams">
  <div class="diagram">
    <canvas id="elGraph"></canvas>
  </div>
</div>
    

    <div class="diagrams">
      <div class="diagram">
        <div id="relVal">REL=</div>
        <div id="blockMsg" style="color:red; font-size:13px; display:none;"></div>
        <canvas id="relCanvas" width="200" height="200"></canvas>
      </div>
    </div>

    <div id="satRangesList"></div>
</div> <!-- closes .card -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>


  <script>
  const relCanvas=document.getElementById("relCanvas");
  const relCtx=relCanvas.getContext('2d');
  const blockMsg=document.getElementById("blockMsg");

  const latEl=document.getElementById('lat'), lonEl=document.getElementById('lon');
  const latDir=document.getElementById('latDir'), lonDir=document.getElementById('lonDir');
  const satLonEl=document.getElementById('satLon'), satLonDir=document.getElementById('satLonDir');
  const headingEl=document.getElementById('heading');
  const refreshBtn=document.getElementById('refreshBtn'), copyBtn=document.getElementById('copyBtn'), pdfBtn=document.getElementById('pdfBtn');
  const azVal=document.getElementById('azVal'), elVal=document.getElementById('elVal'), relVal=document.getElementById('relVal');

  const zonesTable=document.getElementById("zonesTable");
  const zonesBody=document.getElementById("zonesBody");
  const addBlockBtn=document.getElementById("addBlockBtn");
  const satRangesList=document.getElementById("satRangesList");

  const MIN_ELEVATION = 5;  // minimum EL in degrees for visibility


  const zoneColors = [
    "rgba(255, 0, 0, 0.25)",
    "rgba(0, 128, 255, 0.25)",
    "rgba(0, 200, 0, 0.25)",
    "rgba(255, 165, 0, 0.25)",
    "rgba(128, 0, 128, 0.25)",
    "rgba(255, 20, 147, 0.25)"
  ];

  function formatNumber(num) {
    return (Math.round(num * 100) / 100).toString().replace(/\.00$/, "");
  }

  function drawZone(start, stop, isActive, index) {
    let startAZ = (start + 360) % 360;
    let stopAZ  = (stop  + 360) % 360;
    if (stopAZ < startAZ) stopAZ += 360;

    const baseColor = zoneColors[(index - 1) % zoneColors.length];
    const fillColor = isActive ? baseColor.replace("0.25", "0.45") : baseColor;

    relCtx.save();
    relCtx.translate(100, 100);
    relCtx.fillStyle = fillColor;
    relCtx.beginPath();
    relCtx.moveTo(0, 0);
    relCtx.arc(0, 0, 80, (startAZ - 90) * Math.PI / 180, (stopAZ - 90) * Math.PI / 180, false);
    relCtx.closePath();
    relCtx.fill();
    relCtx.restore();
  }

function drawRel(rel) {
  relCtx.clearRect(0, 0, 200, 200);

  if (!vesselImg.complete) {
    vesselImg.onload = () => drawRel(rel);
    return;
  }

  relCtx.save();
  relCtx.translate(100, 100);
  relCtx.drawImage(vesselImg, -110, -110, 220, 220);
  relCtx.restore();

  const results = checkBlockingZones(rel);

  const rows = zonesBody.querySelectorAll("tr");
  rows.forEach((row, idx) => {
    const start = parseFloat(row.cells[0].querySelector("input").value);
    const stop  = parseFloat(row.cells[1].querySelector("input").value);
    if (isNaN(start) || isNaN(stop)) return;
    const isActive = results && results.some(r => r.index === idx + 1);
    drawZone(start, stop, isActive, idx + 1);
  });

  const rad = (rel - 90) * Math.PI / 180;
  relCtx.strokeStyle = results && results.length
    ? zoneColors[(results[0].index - 1) % zoneColors.length].replace("0.25", "1.0")
    : "blue";
  relCtx.lineWidth = 2;
  relCtx.beginPath();
  relCtx.moveTo(100, 100);
  relCtx.lineTo(100 + 70 * Math.cos(rad), 100 + 70 * Math.sin(rad));
  relCtx.stroke();

  if (results && results.length) {
    const msg = results.map(r => `zone ${r.index}`).join(", ");
    const zoneColor = zoneColors[(results[0].index - 1) % zoneColors.length].replace("0.25", "1.0");
    blockMsg.textContent = `Entered in block ${msg}`;
    blockMsg.style.display = "block";
    blockMsg.style.color = zoneColor;
  } else {
    blockMsg.style.display = "none";
  }
}
function resizeCanvas(canvas) {
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * 2;   // ×2 for retina / PDF sharpness
  canvas.height = rect.height * 2;
}

function drawElGraph(lat, lon) {
  
  const canvas = document.getElementById("elGraph");
resizeCanvas(canvas);
const ctx = canvas.getContext("2d");
  

  const margin = 40;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;

  const MIN_ELEVATION = 5;

  // --- coordinate converters ---
  function toX(lonSat) {
    return margin + (lonSat + 180) * (width / 360);
  }

  function toY(el) {
    // Clamp the elevation value to a minimum of 0 to prevent
    // the line from being drawn below the x-axis.
    const clampedEl = Math.max(0, el);
    return canvas.height - margin - (clampedEl / 90) * height;
  }
  
  // normalize longitude into [-180, 180]
  function normalizeLon(lon) {
    return ((lon + 180) % 360 + 360) % 360 - 180;
  }

  // --- clear canvas ---
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // --- background shading ---
  function shadeBand(elMin, elMax, color) {
    const top = toY(elMax);
    const bottom = toY(elMin);
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.2;
    ctx.fillRect(
      toX(-180), top,
      toX(180) - toX(-180), bottom - top
    );
    ctx.globalAlpha = 1.0;
  }
  shadeBand(0, MIN_ELEVATION, "red");     // The area below the MIN_ELEVATION line
  shadeBand(MIN_ELEVATION, 15, "yellow");
  shadeBand(15, 65, "green");
  shadeBand(65, 80, "yellow");
  shadeBand(80, 90, "red");

  // --- axes ---
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(toX(-180), toY(0));
  ctx.lineTo(toX(180), toY(0));
  ctx.moveTo(toX(-180), toY(0));
  ctx.lineTo(toX(-180), toY(90));
  ctx.stroke();

  // --- labels ---
  ctx.fillStyle = "black";
  ctx.font = "12px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText("Satellite Longitude (°)", canvas.width / 2, canvas.height - 5);

  ctx.save();
  ctx.translate(12, canvas.height / 2);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText("Elevation (°)", 0, 0);
  ctx.restore();

  // --- ticks ---
  ctx.textAlign = "center";
  for (let lon = -180; lon <= 180; lon += 60) {
    const x = toX(lon);
    ctx.beginPath();
    ctx.moveTo(x, toY(0));
    ctx.lineTo(x, toY(0) + 5);
    ctx.stroke();
    // Custom label formatting logic
    let label;
    if (lon < 0) {
        label = `${Math.abs(lon)}°W`;
    } else if (lon > 0) {
        label = `${lon}°E`;
    } else {
        label = `0°`;
    }
    ctx.fillText(label, x, toY(0) + 15);
}

  ctx.textAlign = "right";
  for (let el = 0; el <= 90; el += 15) {
    const y = toY(el);
    ctx.beginPath();
    ctx.moveTo(toX(-180), y);
    ctx.lineTo(toX(-180) - 5, y);
    ctx.stroke();
    ctx.fillText(el.toString(), toX(-180) - 8, y + 3);
  }

  // --- compute curve ---
  const satLons = [];
  const elevations = [];
  const step = 1;
  for (let lonSat = -180; lonSat <= 180; lonSat += step) {
    const { el } = calcAzEl(lat, lon, lonSat);
    satLons.push(lonSat);
    elevations.push(el);
  }

  // --- draw curve ---
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 2;
  ctx.beginPath();
  satLons.forEach((lonSat, i) => {
    const x = toX(lonSat);
    const y = toY(elevations[i]); // Use the corrected toY function
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // --- min elevation cutoff line ---
  ctx.strokeStyle = "red";
  ctx.setLineDash([5, 3]);
  ctx.beginPath();
  ctx.moveTo(toX(-180), toY(MIN_ELEVATION));
  ctx.lineTo(toX(180), toY(MIN_ELEVATION));
  ctx.stroke();
  ctx.setLineDash([]);

  // --- vertical marker for selected satellite longitude ---
  let { satLon } = getLatLon();
  satLon = normalizeLon(satLon);

  ctx.strokeStyle = "purple";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(toX(satLon), toY(0));
  ctx.lineTo(toX(satLon), toY(90));
  ctx.stroke();

  // label below axis
  ctx.fillStyle = "purple";
  ctx.font = "12px sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(formatLonEW(satLon), toX(satLon), canvas.height - margin + 28);

  // --- point + label at intersection with curve ---
  const { el: satEl } = calcAzEl(lat, lon, satLon);
  ctx.fillStyle = "purple";
  ctx.beginPath();
  ctx.arc(toX(satLon), toY(satEl), 4, 0, 2 * Math.PI);
  ctx.fill();
  ctx.fillText(`${satEl.toFixed(1)}°`, toX(satLon), toY(satEl) - 8);
}




function formatLonEW(lon) {
  if (lon > 0) return formatNumber(lon) + "°E";
  if (lon < 0) return formatNumber(Math.abs(lon)) + "°W";
  return "0°";
}


function checkBlockingZones(rel) {
  const rows = zonesBody.querySelectorAll("tr");
  const matches = [];
  let zoneIndex = 0;

  for (const row of rows) {
    zoneIndex++;
    const start = parseFloat(row.cells[0].querySelector("input").value);
    const stop  = parseFloat(row.cells[1].querySelector("input").value);
    if (isNaN(start) || isNaN(stop)) continue;

    let startAZ = (start + 360) % 360;
    let stopAZ  = (stop + 360) % 360;

    if (startAZ <= stopAZ) {
      if (rel >= startAZ && rel <= stopAZ) {
        matches.push({ index: zoneIndex, start, stop });
      }
    } else {
      if (rel >= startAZ || rel <= stopAZ) {
        matches.push({ index: zoneIndex, start, stop });
      }
    }
  }

  return matches.length ? matches : null;
}


  function createZoneRow(start=0.00, stop=0.00){
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td><input type="text" inputmode="decimal" value="${formatNumber(start)}"></td>
      <td><input type="text" inputmode="decimal" value="${formatNumber(stop)}"></td>
      <td><button class="small secondary" data-html2canvas-ignore="true">Remove</button></td>
    `;
    const startInput = tr.querySelector("td:nth-child(1) input");
    const stopInput  = tr.querySelector("td:nth-child(2) input");
    [startInput, stopInput].forEach(inp => {
      inp.addEventListener("input", updateAll);
      inp.addEventListener("blur", () => {
        let val = (inp.value || "").trim().replace(",", ".");
        let num = parseFloat(val);
        if(isNaN(num)) num = 0;
        if(num < 0) num = 0;
        if(num > 360) num = 360;
        inp.value = formatNumber(num);
        updateAll();
      });
      inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
    });
    tr.querySelector("button").addEventListener("click",()=>{
      tr.remove();
      if(zonesBody.children.length===0) zonesTable.style.display="none";
      setupKeyboardNavigation(); 
      updateAll();
    });
    zonesBody.appendChild(tr);
    zonesTable.style.display="table";
    setupKeyboardNavigation();
    updateAll();
  }

  addBlockBtn.addEventListener("click",()=>createZoneRow());

  function normalizeInput(input, max){
    let val = (input.value || "").trim().replace(",", ".");
    if(val === "") return;
    let num = parseFloat(val);
    if(isNaN(num)) return;
    if(num > max) num = max;
    if(num < 0) num = 0;
    input.value = formatNumber(num);
  }

  function getLatLon(){
    const latVal = parseFloat((latEl.value || "").trim().replace(",", ".")) || 0;
    const lonVal = parseFloat((lonEl.value || "").trim().replace(",", ".")) || 0;
    const satLonVal = parseFloat((satLonEl.value || "").trim().replace(",", ".")) || 0;
    const headingVal = parseFloat((headingEl.value || "").trim().replace(",", ".")) || 0;
    const lat = latDir.value === "N" ? latVal : -latVal;
    const lon = lonDir.value === "E" ? lonVal : -lonVal;
    const satLon = satLonDir.value === "E" ? satLonVal : -satLonVal;
    return { lat, lon, satLon, heading: headingVal };
  }

  function calcAzEl(lat,lon,satLon){
    const Re=6378.137,h=35786.0;
    const latR=lat*Math.PI/180, lonR=lon*Math.PI/180, satLonR=satLon*Math.PI/180;
    const xObs=Re*Math.cos(latR)*Math.cos(lonR), yObs=Re*Math.cos(latR)*Math.sin(lonR), zObs=Re*Math.sin(latR);
    const xSat=(Re+h)*Math.cos(satLonR), ySat=(Re+h)*Math.sin(satLonR), zSat=0;
    const dx=xSat-xObs, dy=ySat-yObs, dz=zSat-zObs;
    const e=-Math.sin(lonR)*dx+Math.cos(lonR)*dy;
    const n=-Math.sin(latR)*Math.cos(lonR)*dx -Math.sin(latR)*Math.sin(lonR)*dy +Math.cos(latR)*dz;
    const u=Math.cos(latR)*Math.cos(lonR)*dx +Math.cos(latR)*Math.sin(lonR)*dy +Math.sin(latR)*dz;
    let az=Math.atan2(e,n)*180/Math.PI; if(az<0)az+=360;
    const el=Math.atan2(u,Math.sqrt(e*e+n*n))*180/Math.PI;
    return {az,el};
  }

  const vesselImg=new Image();
  vesselImg.src="https://pgarciafer.github.io/satcalc/IMG_0585.PNG";

function updateAll(){
  const {lat,lon,satLon,heading}=getLatLon();
  const {az,el}=calcAzEl(lat,lon,satLon);
  azVal.textContent='AZ='+formatNumber(az);

  // EL value handling
  if (el < MIN_ELEVATION) {
    elVal.innerHTML = `EL=<span style="color:red;">${formatNumber(el)} (Out of Range)</span>`;
  } else {
    elVal.textContent = 'EL=' + formatNumber(el);
  }

  // Compute visible range of satellite longitudes (EL > 0)
  const step = 0.5; // resolution in degrees
  let visibleLons = [];
  for (let lonSat = -180; lonSat <= 180; lonSat += step) {
    const { el: testEl } = calcAzEl(lat, lon, lonSat);
    if (testEl > MIN_ELEVATION) visibleLons.push(lonSat);
  }

  if (visibleLons.length > 0) {
    const minLonRaw = Math.min(...visibleLons);
const maxLonRaw = Math.max(...visibleLons);
const minLon = formatLonEW(minLonRaw);
const maxLon = formatLonEW(maxLonRaw);
document.getElementById("visibleRange").textContent =
  `Visible range (EL > ${MIN_ELEVATION}) from ${minLon} to ${maxLon}`;

  } else {
    document.getElementById("visibleRange").textContent =
      `No satellites visible above horizon`;
  }

  const rel=((az-heading)+360)%360;
  relVal.textContent='REL='+formatNumber(rel);
  drawRel(rel);
  copyBtn.disabled=false;
  pdfBtn.disabled=false;
  computeSatRangesAndRender();
  
  drawElGraph(lat, lon);
  
}



  async function getAndShowLocation(){
    if(!('geolocation' in navigator)){ alert("Geolocation not supported."); return; }
    const opts={enableHighAccuracy:true,maximumAge:0,timeout:20000};
    return new Promise(resolve=>{
      navigator.geolocation.getCurrentPosition(pos=>{
        const c=pos.coords;
        latEl.value=formatNumber(Math.abs(c.latitude));
        latDir.value=c.latitude>=0?"N":"S";
        lonEl.value=formatNumber(Math.abs(c.longitude));
        lonDir.value=c.longitude>=0?"E":"W";
        updateAll();
        resolve();
      },err=>{alert('Location error: '+err.message);resolve();},opts);
    });
  }

  refreshBtn.addEventListener("click",()=>getAndShowLocation());



copyBtn.addEventListener("click",()=>{
   const {lat,lon,satLon,heading}=getLatLon();

  // format latitude
  const latText = formatNumber(Math.abs(lat)) + "°" + (lat >= 0 ? "N" : "S");

  // format longitude
  const lonText = formatNumber(Math.abs(lon)) + "°" + (lon >= 0 ? "E" : "W");

  // format satellite longitude (using your helper)
  const satLonText = formatLonEW(satLon);

  // base info
  let text = `Lat=${latText}\nLon=${lonText}\nSatLon=${satLonText}\nHeading=${heading}\n\n`;

  // add visible range (EL > MIN_ELEVATION)
  const visibleRangeEl = document.getElementById("visibleRange");
  if (visibleRangeEl && visibleRangeEl.textContent.trim() !== "") {
    text += visibleRangeEl.textContent + "\n\n";
  }

  // add Blockage Zones
  const rows = Array.from(zonesBody.querySelectorAll("tr"));
  if (rows.length > 0) {
    text += "Blockage Zones:\n";
    rows.forEach((row, idx) => {
      const start = row.cells[0].querySelector("input").value;
      const stop  = row.cells[1].querySelector("input").value;
      text += `  Zone ${idx+1}: ${start}°–${stop}°\n`;
    });
  }

  // add blocking ranges (from satRangesList)
  const ranges = satRangesList.innerText.trim();
  if (ranges !== "") {
    text += "Blocking ranges:\n" + ranges + "\n";
  }

  // copy to clipboard
  navigator.clipboard.writeText(text).then(()=>{
    copyBtn.textContent="Copied!";
    setTimeout(()=>copyBtn.textContent="Copy",1000);
  });
});




pdfBtn.addEventListener("click", async () => {
  const card = document.querySelector(".card");

  // Hide buttons temporarily
  const ignoredEls = card.querySelectorAll("[data-html2canvas-ignore='true']");
  ignoredEls.forEach(el => el.style.visibility = "hidden");

  // Capture card at high resolution (force desktop width so mobile looks same)
  const canvas = await html2canvas(card, {
    scale: 2,
    useCORS: true,
    windowWidth: 1200
  });

  // Restore buttons BEFORE generating PDF
  ignoredEls.forEach(el => el.style.visibility = "");

  // === SCALE TO A4 SIZE (same as before) ===
  const a4WidthPx = 1240;   // ≈ A4 width at 150 DPI
  const a4HeightPx = 1754;  // ≈ A4 height at 150 DPI
  const tempCanvas = document.createElement("canvas");
  tempCanvas.width = a4WidthPx;
  tempCanvas.height = a4HeightPx;
  const ctx = tempCanvas.getContext("2d");

  // Fill white background
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, a4WidthPx, a4HeightPx);

  // Scale the captured image to fit inside A4
  const imgWidth = a4WidthPx - 100; // 50px margin each side
  const imgHeight = (canvas.height * imgWidth) / canvas.width;
  const xOffset = (a4WidthPx - imgWidth) / 2;
  const yOffset = (a4HeightPx - imgHeight) / 2;
  ctx.drawImage(canvas, xOffset, yOffset, imgWidth, imgHeight);

  // === Convert scaled canvas to PDF ===
  const imgData = tempCanvas.toDataURL("image/jpeg", 0.98);
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({
    orientation: "portrait",
    unit: "px",
    format: [a4WidthPx, a4HeightPx]
  });

  pdf.addImage(imgData, "JPEG", 0, 0, a4WidthPx, a4HeightPx);
  pdf.save("satellite-calculator.pdf");
});













[latEl, lonEl, satLonEl].forEach(inp=>{
  inp.addEventListener("blur",()=>{
    normalizeInput(inp,180);   // lat/lon/satLon limited to ±180
    updateAll();
  });
  inp.addEventListener("input",updateAll);
  inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
});

headingEl.addEventListener("blur",()=>{
  normalizeInput(headingEl,360);   // heading limited to 0–360
  updateAll();
});
headingEl.addEventListener("input",updateAll);
headingEl.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
  [latDir,lonDir,satLonDir].forEach(sel=>sel.addEventListener("change",updateAll));

  // === SATELLITE RANGE CALCULATION ===
function computeSatRangesForZone(startAZ, stopAZ, lat, lon, heading, step = 1) {
  // normalize azimuth window to [0,360)
  const start = (startAZ + 360) % 360;
  const stop  = (stopAZ + 360) % 360;
  const segments = [];
  let inside = false;
  let segStart = null;

  // integer loop to avoid floating accumulation drift
  const nSteps = Math.round((360 / step));
  for (let i = 0; i <= nSteps; i++) {
    // compute satLon exactly from index
    const satLon = -180 + i * step;
    const { az, el } = calcAzEl(lat, lon, satLon);

    // skip below-horizon satellites (EL < 0 are out of range)
    if (el < 0) {
      if (inside) {
        // we left a visible segment because satellite dropped below horizon.
        // do a small interpolation to estimate more accurate end boundary
        const endEstimate = refineBoundary(segStart, satLon - step, lat, lon, heading, start, stop, step);
        segments.push([segStart, endEstimate]);
        inside = false;
        segStart = null;
      }
      continue;
    }

    const rel = ((az - heading) + 360) % 360;
    let inZone = false;
    if (start <= stop) {
      inZone = (rel >= start && rel <= stop);
    } else {
      inZone = (rel >= start || rel <= stop);
    }

    if (inZone && !inside) {
      // entering a segment: refine entry boundary
      const entry = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step, true);
      segStart = entry;
      inside = true;
    } else if (!inZone && inside) {
      // leaving a segment: refine exit boundary
      const exit = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step);
      segments.push([segStart, exit]);
      inside = false;
      segStart = null;
    }
  }

  // if still inside at the end of sweep, close at +180
  if (inside) {
    segments.push([segStart, 180]);
  }

  console.debug('computeSatRangesForZone', { startAZ, stopAZ, segments });
  return segments;
}

// Helper: refine boundary between satLonA and satLonB
// If findEntry===true we return the earliest satLon within that small interval that produces inZone true.
// Otherwise return the latest satLon within the interval that produces inZone true.
function refineBoundary(a, b, lat, lon, heading, start, stop, coarseStep, findEntry=false) {
  // clamp
  if (a < -180) a = -180;
  if (b > 180) b = 180;
  const subSteps = 10;
  let best = findEntry ? b : a;
  for (let k = 0; k <= subSteps; k++) {
    const t = k / subSteps;
    const satLon = a + (b - a) * t;
    const { az, el } = calcAzEl(lat, lon, satLon);
    if (el < 0) continue;
    const rel = ((az - heading) + 360) % 360;
    let inZone = false;
    if (start <= stop) inZone = (rel >= start && rel <= stop);
    else inZone = (rel >= start || rel <= stop);
    if (inZone) {
      if (findEntry) {
        best = Math.min(best, satLon);
      } else {
        best = Math.max(best, satLon);
      }
    }
  }
  return Math.round(best * 100) / 100; // round to 0.01°
}



  function computeSatRangesAndRender(){
    const { lat, lon, heading } = getLatLon();
    const rows = Array.from(zonesBody.querySelectorAll('tr'));
    if(rows.length === 0){
      satRangesList.innerHTML = "<i>(no Blockage Zones)</i>";
      return;
    }
    const sampleStep = 0.5;
    const outPieces = [];

    rows.forEach((row, idx) => {
      const start = parseFloat(row.cells[0].querySelector("input").value);
      const stop  = parseFloat(row.cells[1].querySelector("input").value);
      if(isNaN(start) || isNaN(stop)) return;

      let ranges = computeSatRangesForZone(start, stop, lat, lon, heading, sampleStep);

      const west = [], east = [];
      ranges.forEach(([a,b])=>{
        // convert segment endpoints to [-180,180]
        let A = ((a+540)%360)-180;
        let B = ((b+540)%360)-180;
        // ensure A <= B for this segment (segments from computeSatRangesForZone won't wrap across >180)
        if(A > B){ const tmp = A; A = B; B = tmp; }

        if(B <= 0) {
          // both points west (negative longitudes). convert to positive west degrees 0..180
          const lo = Math.abs(B); // smaller magnitude (closer to Greenwich)
          const hi = Math.abs(A); // larger magnitude (further west)
          west.push([lo, hi]);
        } else if (A >= 0) {
          // both points east
          east.push([A, B]);
        } else {
          // crosses Greenwich (A < 0 < B) -> split into two ordered parts:
          // west part: |A| .. 180 (in °W), east part: 0 .. B (in °E)
          west.push([Math.abs(A), 180]);
          east.push([0, B]);
        }
      });

      // merge helper (merge overlapping/adjacent intervals)
      function mergeIntervals(list){
        if(list.length<=1) return list;
        list.sort((a,b)=>a[0]-b[0]);
        const merged=[list[0].slice()];
        for(let i=1;i<list.length;i++){
          const [s,e]=list[i];
          const last=merged[merged.length-1];
          if(s <= last[1] + 0.5){ last[1]=Math.max(last[1],e);} 
          else merged.push([s,e]);
        }
        return merged;
      }

      const mergedWest = mergeIntervals(west);
      const mergedEast = mergeIntervals(east);

      const parts = [];

      // format west: always 0W -> 180W, smaller -> larger (e.g., 11.5°W to 26°W)
      mergedWest.forEach(([lo,hi])=>{
        // ensure numeric order lo <= hi
        if(hi < lo) { const t = lo; lo = hi; hi = t; }
        parts.push(`${formatNumber(lo)}°W to ${formatNumber(hi)}°W`);
      });

      // format east: always 0E -> 180E, smaller -> larger
      mergedEast.forEach(([lo,hi])=>{
        if(hi < lo) { const t = lo; lo = hi; hi = t; }
        parts.push(`${formatNumber(lo)}°E to ${formatNumber(hi)}°E`);
      });

      if(parts.length===0){
        outPieces.push(`<div class="zone-range"><span class="color" style="background:${zoneColors[idx % zoneColors.length].replace("0.25","1.0")}"></span> Zone ${idx+1} No visible Sat produces blockage here</div>`);
      } else {
        outPieces.push(`<div class="zone-range"><span class="color" style="background:${zoneColors[idx % zoneColors.length].replace("0.25","1.0")}"></span> Zone ${idx+1} Blockage Zone range:  ${parts.join(', ')}</div>`);
      }
    });

    satRangesList.innerHTML = outPieces.join('');
  }

  // Keyboard navigation setup
function setupKeyboardNavigation() {
  const focusable = Array.from(document.querySelectorAll("input, select"));

  focusable.forEach((el, idx) => {
    // remove any existing listener first
    el.onkeydown = (e) => {
      let newIndex = null;

      // only override Enter if not inside a select
      if (e.key === "Enter" && el.tagName !== "SELECT") {
        e.preventDefault();
        newIndex = e.shiftKey ? idx - 1 : idx + 1;
      }

      // only override arrow navigation if not inside a select
      if (el.tagName !== "SELECT") {
        if (e.key === "ArrowRight" || e.key === "ArrowDown") {
          e.preventDefault();
          newIndex = idx + 1;
        }
        if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
          e.preventDefault();
          newIndex = idx - 1;
        }
      }

      if (newIndex !== null) {
        if (newIndex < 0) newIndex = focusable.length - 1;
        if (newIndex >= focusable.length) newIndex = 0;
        focusable[newIndex].focus();
      }
    };
  });
}


window.addEventListener('DOMContentLoaded', () => {
  setupKeyboardNavigation();
  updateAll();
});

// Global error handler
// Global error handler
window.addEventListener("error", function (event) {
  let msg = document.getElementById("errorBox");
  if (!msg) {
    msg = document.createElement("div");
    msg.id = "errorBox";
    msg.style.background = "#fee";
    msg.style.color = "red";
    msg.style.padding = "8px";
    msg.style.border = "1px solid red";
    msg.style.margin = "10px 0";
    msg.style.fontWeight = "bold";
    document.body.prepend(msg);
  }
  msg.textContent = "⚠️ Error: " + event.message + " (line " + event.lineno + ")";
});
window.addEventListener("resize", updateAll);
  </script>
  
</body>
</html>
