<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Satellite Look Angle Calculator</title>
  <style>
  :root { font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial; }
  body {
    display: flex;
    justify-content: center;
    align-items: flex-start;
    min-height: 100vh;
    margin: 0;
    padding: 20px;
    background: linear-gradient(180deg,#f8fafc,#eef2ff);
  }
  .card {
    background: #ffffff;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.08);
    padding: 20px;
    width: 100%;
    max-width: 500px;
  }
  h1 { font-size: 18px; margin-bottom: 16px; color: #0f172a; text-align: center; }

#vessel-diagram-container {
  margin-bottom: -20px; /* Example: Pulls the element below it closer by 6px */
}
  .coord-item {
    display: grid;
    grid-template-columns: minmax(60px,100px) 1fr auto;
    align-items: center;
    gap: 5px;
    background: #f8fafc;
    padding: 5px 11px;
    border-radius: 8px;
    margin-bottom: 6px;
  }
  .coord-item label { margin: 0; color: #0f172a; font-weight: 500; }
  .coord-item input {
    width: 100%; min-width: 0; text-align: center;
    border: none; background: transparent;
    font-size: 15px; color: #0f172a; outline: none; padding: 4px 4px;
  }
  .coord-item input:focus { background: #e0f2fe; border-radius: 4px; }
  .coord-item select {
    font-size: 13px; padding: 4px 4px; border-radius: 6px; border: 1px solid #cbd5e1;
    background: white; color: #0f172a; min-width: 48px;
  }

  button {
    padding: 8px 12px; border-radius: 8px; border: 0; background: #0ea5a4; color: white;
    cursor: pointer; font-weight: 500;
  }
  button.secondary { background: #64748b; }
  button.small { padding: 4px 8px; font-size: 13px; width: auto; }

  .button-row {
    display: flex;
    flex-direction: column;
    gap: 6px;
    justify-content: center;
    margin-bottom: 12px;
  }

  table { width: 100%; border-collapse: collapse; margin-top: 8px; }
  th, td { text-align: center; padding: 6px; border-bottom: 1px solid #e2e8f0; }
  th { color: #0f172a; font-weight: 600; }
  td input { width: 90px; text-align: center; }
  #zonesTable td button { width: 24px; height: 24px; font-size: 14px; border: none; background: #e74c3c; color: #fff; border-radius: 3px; cursor: pointer; padding: 0; float: right; }
  #zonesTable td button:hover { background: #c0392b; }
  #zonesTable td input:focus { background: #e0f2fe; border-radius: 4px; }

  #satRangesList { 
  margin-top: 6px; 
  font-size: 14px; 
  line-height: 1.4; 
    display: grid;
  grid-template-columns: 1fr; /* default single column */
  gap: 6px 16px; /* spacing between rows/cols */
  }
  /* if more than one entry, switch to two columns */
#satRangesList.two-col {
  grid-template-columns: 1fr 1fr;
}

  .zone-range { margin: 4px 0; }
  .zone-range .color { display: inline-block; width: 12px; height: 12px; border-radius: 50%; margin-right: 6px; }

  canvas { 
  background: white; 
  border-radius: 8px; 
  width: 100%; 
  max-width: 400px; /* Limits the max width of the diagram */
    height: auto;   /* Set a fixed height */}

  .diagram { 
  display: flex; 
  flex-direction: column; 
  align-items: center; 
  margin-bottom: 12px; }

  .diagram-info { display: flex; 
  flex-direction: column; 
  align-items: center; 
  margin-bottom: 6px; }
  .diagram-info div { margin-bottom: 4px; }

  .main-column { display: flex; flex-direction: column; gap: 5px; }

.blocking-section {
  width: 100%;
  display: flex;
  flex-direction: column; /* Stack children vertically */
  align-items: center; /* Center children horizontally */
}
  .blocking-section label { font-weight: 600; margin-bottom: 4px; display: block; }

  .blocking-section .header-center {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .blocking-section label {
    font-weight: 600;
  }
  
  /* Responsive Layout (new) */
  .responsive-layout {
    display: grid;
    grid-template-columns: 1fr; /* Default: mobile-first, single column */
    gap: 12px;
  }
  
  /* PDF-specific styles */
  .pdf-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto auto;
    gap: 12px;
    width: 100%;
    font-size: 14px;
  }

  .pdf-cell {
    border: 1px solid #ccc;
    padding: 8px;
  }
  
  /* Old styles to be removed */
  .two-column-layout, .three-column-layout {
    display: none;
  }

  /* Media Queries */
  /* Desktop layout (for screens wider than 600px) */
  @media (min-width: 600px) {
    .card {
      max-width: 600px;
    }
    .responsive-layout {
      grid-template-columns: 1fr 1fr; /* Three-column layout */
    }
      .button-row {
    display: flex;
	flex-direction: row; /* Changed to row to align items horizontally */
    justify-content: center;
    gap: 6px;
    margin-bottom: 12px;
  }
  }
  
    /* The new rule for the EL graph and sat range list section */
  .centered-stacked-layout {
    display: flex;
    flex-direction: column; /* Stack the children vertically */
    align-items: center; /* Center the children horizontally */
    gap: 12px; /* Add some space between the two elements */
    margin-top: 12px;
  }
  
  /* Print layout (for PDF generation) */
  @media print {
    body, .card {
      padding: 0 !important;
      margin: 0 !important;
      max-width: none !important;
    }
    .main-column {
      padding: 10mm;
    }
  }
  
  #visibleRange {
  text-align: center;
}



</style>
</head>
<body>
  <div class="card" role="region" aria-label="Device coordinates">
    <h1>Satellite Look Angle Calculator</h1>

    <div class="main-column">

      <div class="button-row">
        <button id="refreshBtn" class="small" data-html2canvas-ignore="true">Get Location</button>
        <button id="copyBtn" class="small secondary" disabled data-html2canvas-ignore="true">Copy</button>
        <button id="pdfBtn" class="small secondary" data-html2canvas-ignore="true">PDF</button>
      </div>

      <div class="responsive-layout">
        <div class="coords" aria-live="polite">
          <div class="coord-item">
            <label for="lat">Latitude</label>
            <input id="lat" type="text" inputmode="decimal" value="38.88" />
            <select id="latDir"><option value="N" selected>N</option><option value="S">S</option></select>
          </div>
          <div class="coord-item">
            <label for="lon">Longitude</label>
            <input id="lon" type="text" inputmode="decimal" value="1.40" />
            <select id="lonDir"><option value="E" selected>E</option><option value="W">W</option></select>
          </div>
          <div class="coord-item">
            <label for="satLon">Satellite Longitude</label>
            <input id="satLon" type="text" inputmode="decimal" value="18.00" />
            <select id="satLonDir"><option value="E">E</option><option value="W" selected>W</option></select>
          </div>
          <div class="coord-item">
            <label for="heading">Heading</label>
            <input id="heading" type="text" inputmode="decimal" value="0.00" />
            <div style="width:48px;"></div>
          </div>
        </div>

        <div class="blocking-section" id="blockingZonesSection">
          <div class="header-center">
            <label>Blockage Zones</label>
          </div>
          <table id="zonesTable" style="display:none;">
            <thead>
              <tr>
                <th>AZ Start</th>
                <th>AZ Stop</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="zonesBody"></tbody>
          </table>
          <button type="button" id="addBlockBtn" data-html2canvas-ignore="true">Add Blockage Zone</button>
        </div>
      </div>

      <div class="responsive-layout">
        <div class="diagram-info">
          <div id="azVal">AZ=</div>
          <div id="elVal">EL=</div>
          <div id="relVal" style="font-weight:bold">REL=</div>
		  <div id="relBlockMsg" style="font-weight:bold; margin-top:4px;"></div>
          <div id="visibleRange" style="font-weight:bold;"></div>
        </div>
        <div id="vessel-diagram-container" class="diagram">
    <canvas id="vesselCanvas" width="300" height="300"></canvas>
</div>
      </div>

    <div class="centered-stacked-layout">
      <div class="diagram">
        <canvas id="elGraph" width="300" height="150"></canvas>
      </div>
      <div id="satRangesList"></div>
    </div>
    </div>
  </div>
    
  <div id="pdfLayout" style="display:none;"></div>
    
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    const latEl=document.getElementById('lat'), lonEl=document.getElementById('lon');
    const latDir=document.getElementById('latDir'), lonDir=document.getElementById('lonDir');
    const satLonEl=document.getElementById('satLon'), satLonDir=document.getElementById('satLonDir');
    const headingEl=document.getElementById('heading');
    const refreshBtn=document.getElementById('refreshBtn'), copyBtn=document.getElementById('copyBtn'), pdfBtn=document.getElementById('pdfBtn');
    const azVal=document.getElementById('azVal'), elVal=document.getElementById('elVal'), relVal=document.getElementById('relVal');
    const zonesTable=document.getElementById("zonesTable");
    const zonesBody=document.getElementById("zonesBody");
    const addBlockBtn=document.getElementById("addBlockBtn");
    const satRangesList=document.getElementById("satRangesList");
    const MIN_ELEVATION = 5;
    const zoneColors = [
      "rgba(255, 0, 0, 0.5)",
      "rgba(0, 128, 255, 0.5)",
      "rgba(0, 200, 0, 0.5)",
      "rgba(255, 165, 0, 0.5)",
      "rgba(128, 0, 128, 0.5)",
      "rgba(255, 20, 147, 0.5)"
    ];
    function formatNumber(num) {
      return (Math.round(num * 100) / 100).toString().replace(/\.00$/, "");
    }
    function resizeCanvas(canvas) {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * 2;
      canvas.height = rect.height * 2;
    }
    function adjustGraphHeight() {
      const canvas = document.getElementById("elGraph");
      const table = document.getElementById("zonesTable");
      if (!canvas || !table) return;
      const rowCount = table.querySelectorAll("tbody tr").length;
      const baseHeight = 200;
      const extraPerRow = 25;
      const newHeight = baseHeight + rowCount * extraPerRow;
      canvas.style.height = newHeight + "px";
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * 2;
      canvas.height = newHeight * 2;
    }
	
function drawElGraph(lat, lon) {
  const canvas = document.getElementById("elGraph");
  resizeCanvas(canvas);
  const ctx = canvas.getContext("2d");

  const margin = 40;
  const width = canvas.width - 2 * margin;
  const height = canvas.height - 2 * margin;
  const MIN_ELEVATION = 5;

  // --- Compute visible longitude range --- // <<< changed
  const step = 0.5;
  let visibleLons = [];
  for (let lonSat = -180; lonSat <= 180; lonSat += step) {
    const { el: testEl } = calcAzEl(lat, lon, lonSat);
    if (testEl > MIN_ELEVATION) visibleLons.push(lonSat);
  }
  let minVisible = -180, maxVisible = 180;
  if (visibleLons.length > 0) {
    minVisible = Math.min(...visibleLons) - 5;
    maxVisible = Math.max(...visibleLons) + 5;
    if (minVisible < -180) minVisible = -180;
    if (maxVisible > 180) maxVisible = 180;
  }

  // --- Scaling functions now depend on [minVisible,maxVisible] --- // <<< changed
  function toX(lonSat) {
    return margin + (lonSat - minVisible) * (width / (maxVisible - minVisible));
  }
  function toY(el) {
    const clampedEl = Math.max(0, el);
    return canvas.height - margin - (clampedEl / 90) * height;
  }
  function normalizeLon(lon) {
    return ((lon + 180) % 360 + 360) % 360 - 180;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // --- Background shading bands (use full visible range) --- // <<< changed
  function shadeBand(elMin, elMax, color) {
    const top = toY(elMax);
    const bottom = toY(elMin);
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.2;
    ctx.fillRect(toX(minVisible), top, toX(maxVisible) - toX(minVisible), bottom - top);
    ctx.globalAlpha = 1.0;
  }
  shadeBand(0, MIN_ELEVATION, "red");
  shadeBand(MIN_ELEVATION, 15, "yellow");
  shadeBand(15, 65, "green");
  shadeBand(65, 80, "yellow");
  shadeBand(80, 90, "red");

  // --- Zone highlighting (uses new scaling) ---
  const { heading } = getLatLon();
  const rows = Array.from(zonesBody.querySelectorAll('tr'));
  if (rows.length > 0) {
    ctx.globalAlpha = 0.25;
    const step = 0.5;
    rows.forEach((row, idx) => {
      const start = parseFloat(row.cells[0].querySelector("input").value);
      const stop = parseFloat(row.cells[1].querySelector("input").value);
      if (isNaN(start) || isNaN(stop)) return;
      const ranges = computeSatRangesForZone(start, stop, lat, lon, heading, step);
      ctx.fillStyle = zoneColors[idx % zoneColors.length];
      ranges.forEach(([startLon, endLon]) => {
        const xStart = toX(startLon);
        const xEnd = toX(endLon);
        const yTop = toY(90);
        const yBottom = toY(0);
        ctx.fillRect(xStart, yTop, xEnd - xStart, yBottom - yTop);
      });
    });
    ctx.globalAlpha = 1.0;
  }

  // --- Axes ---
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(toX(minVisible), toY(0));
  ctx.lineTo(toX(maxVisible), toY(0));
  ctx.moveTo(toX(minVisible), toY(0));
  ctx.lineTo(toX(minVisible), toY(90));
  ctx.stroke();

  ctx.fillStyle = "black";
  ctx.font = "20px sans-serif";
  ctx.textAlign = "center";

  // Longitude ticks
  const tickStep = 30; // <<< changed: adapt step for clarity
  for (let lon = Math.ceil(minVisible / tickStep) * tickStep; lon <= maxVisible; lon += tickStep) {
    const x = toX(lon);
    ctx.beginPath();
    ctx.moveTo(x, toY(0));
    ctx.lineTo(x, toY(0) + 5);
    ctx.stroke();
    let label;
    if (lon < 0) {
      label = `${Math.abs(lon)}°W`;
    } else if (lon > 0) {
      label = `${lon}°E`;
    } else {
      label = `0°`;
    }
    ctx.fillText(label, x, toY(0) + 15);
  }

// <<< Add explicit labels for minVisible / maxVisible
  ctx.fillStyle = "black";
  ctx.font = "18px sans-serif";
  ctx.textAlign = "center";

  // Left edge label
  ctx.fillText(
    formatLonEW(Math.round(minVisible)),
    toX(minVisible),
    toY(0) + 30
  );

  // Right edge label
  ctx.fillText(
    formatLonEW(Math.round(maxVisible)),
    toX(maxVisible),
    toY(0) + 30
  );
  // Elevation ticks
  ctx.textAlign = "right";
  for (let el = 0; el <= 90; el += 15) {
    const y = toY(el);
    ctx.beginPath();
    ctx.moveTo(toX(minVisible), y);
    ctx.lineTo(toX(minVisible) - 5, y);
    ctx.stroke();
    ctx.fillText(el.toString(), toX(minVisible) - 8, y + 3);
  }

  // --- Plot satellite elevation curve ---
  const satLons = [];
  const elevations = [];
  const satLonStep = 1;
  for (let lonSat = minVisible; lonSat <= maxVisible; lonSat += satLonStep) {
    const { el } = calcAzEl(lat, lon, lonSat);
    satLons.push(lonSat);
    elevations.push(el);
  }
  ctx.strokeStyle = "blue";
  ctx.lineWidth = 2;
  ctx.beginPath();
  satLons.forEach((lonSat, i) => {
    const x = toX(lonSat);
    const y = toY(elevations[i]);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  ctx.stroke();

  // --- Min elevation reference line ---
  ctx.strokeStyle = "red";
  ctx.setLineDash([5, 3]);
  ctx.beginPath();
  ctx.moveTo(toX(minVisible), toY(MIN_ELEVATION));
  ctx.lineTo(toX(maxVisible), toY(MIN_ELEVATION));
  ctx.stroke();
  ctx.setLineDash([]);

  // --- Current satellite position ---
  let { satLon } = getLatLon();
  satLon = normalizeLon(satLon);
  if (satLon >= minVisible && satLon <= maxVisible) { // <<< changed
    ctx.strokeStyle = "purple";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(toX(satLon), toY(0));
    ctx.lineTo(toX(satLon), toY(90));
    ctx.stroke();

    ctx.fillStyle = "purple";
    ctx.font = "22px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText(formatLonEW(satLon), toX(satLon), canvas.height - margin + 28);

    const { el: satEl } = calcAzEl(lat, lon, satLon);
    ctx.beginPath();
    ctx.arc(toX(satLon), toY(satEl), 4, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillText(`${satEl.toFixed(1)}°`, toX(satLon), toY(satEl) - 8);
  }
}

	
	
	
    function formatLonEW(lon) {
      if (lon > 0) return formatNumber(lon) + "°E";
      if (lon < 0) return formatNumber(Math.abs(lon)) + "°W";
      return "0°";
    }
    function checkBlockingZones(rel) {
      const rows = zonesBody.querySelectorAll("tr");
      const matches = [];
      let zoneIndex = 0;
      for (const row of rows) {
        zoneIndex++;
        const start = parseFloat(row.cells[0].querySelector("input").value);
        const stop = parseFloat(row.cells[1].querySelector("input").value);
        if (isNaN(start) || isNaN(stop)) continue;
        let startAZ = (start + 360) % 360;
        let stopAZ = (stop + 360) % 360;
        if (startAZ <= stopAZ) {
          if (rel >= startAZ && rel <= stopAZ) {
            matches.push({ index: zoneIndex, start, stop });
          }
        } else {
          if (rel >= startAZ || rel <= stopAZ) {
            matches.push({ index: zoneIndex, start, stop });
          }
        }
      }
      return matches.length ? matches : null;
    }
    function createZoneRow(start = 0.00, stop = 0.00) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input type="text" inputmode="decimal" value="${formatNumber(start)}"></td>
        <td><input type="text" inputmode="decimal" value="${formatNumber(stop)}"></td>
        <td><button class="small secondary" data-html2canvas-ignore="true">X</button></td>
      `;
      const startInput = tr.querySelector("td:nth-child(1) input");
      const stopInput = tr.querySelector("td:nth-child(2) input");
      [startInput, stopInput].forEach(inp => {
        inp.addEventListener("input", updateAll);
        inp.addEventListener("blur", () => {
          let val = (inp.value || "").trim().replace(",", ".");
          let num = parseFloat(val);
          if (isNaN(num)) num = 0;
          if (num < 0) num = 0;
          if (num > 360) num = 360;
          inp.value = formatNumber(num);
          updateAll();
        });
        inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
      });
      tr.querySelector("button").addEventListener("click", () => {
        tr.remove();
        if (zonesBody.children.length === 0) zonesTable.style.display = "none";
        setupKeyboardNavigation();
        updateAll();
      });
      zonesBody.appendChild(tr);
      zonesTable.style.display = "table";
      setupKeyboardNavigation();
      updateAll();
    }
    addBlockBtn.addEventListener("click", () => createZoneRow());
    function normalizeInput(input, max) {
      let val = (input.value || "").trim().replace(",", ".");
      if (val === "") return;
      let num = parseFloat(val);
      if (isNaN(num)) return;
      if (num > max) num = max;
      if (num < 0) num = 0;
      input.value = formatNumber(num);
    }
    function getLatLon() {
      const latVal = parseFloat((latEl.value || "").trim().replace(",", ".")) || 0;
      const lonVal = parseFloat((lonEl.value || "").trim().replace(",", ".")) || 0;
      const satLonVal = parseFloat((satLonEl.value || "").trim().replace(",", ".")) || 0;
      const headingVal = parseFloat((headingEl.value || "").trim().replace(",", ".")) || 0;
      const lat = latDir.value === "N" ? latVal : -latVal;
      const lon = lonDir.value === "E" ? lonVal : -lonVal;
      const satLon = satLonDir.value === "E" ? satLonVal : -satLonVal;
      return { lat, lon, satLon, heading: headingVal };
    }
    function calcAzEl(lat, lon, satLon) {
      const Re = 6378.137, h = 35786.0;
      const latR = lat * Math.PI / 180, lonR = lon * Math.PI / 180, satLonR = satLon * Math.PI / 180;
      const xObs = Re * Math.cos(latR) * Math.cos(lonR), yObs = Re * Math.cos(latR) * Math.sin(lonR), zObs = Re * Math.sin(latR);
      const xSat = (Re + h) * Math.cos(satLonR), ySat = (Re + h) * Math.sin(satLonR), zSat = 0;
      const dx = xSat - xObs, dy = ySat - yObs, dz = zSat - zObs;
      const e = -Math.sin(lonR) * dx + Math.cos(lonR) * dy;
      const n = -Math.sin(latR) * Math.cos(lonR) * dx - Math.sin(latR) * Math.sin(lonR) * dy + Math.cos(latR) * dz;
      const u = Math.cos(latR) * Math.cos(lonR) * dx + Math.cos(latR) * Math.sin(lonR) * dy + Math.sin(latR) * dz;
      let az = Math.atan2(e, n) * 180 / Math.PI;
      if (az < 0) az += 360;
      const el = Math.atan2(u, Math.sqrt(e * e + n * n)) * 180 / Math.PI;
      return { az, el };
    }
    const vesselImg = new Image();
    vesselImg.src = "https://pgarciafer.github.io/satcalc/IMG_0585.PNG";
    const vesselCanvas = document.getElementById("vesselCanvas");
    const vesselCtx = vesselCanvas.getContext("2d");
function drawVesselWithREL(rel) {
  vesselCtx.clearRect(0, 0, vesselCanvas.width, vesselCanvas.height);

  const scaleFactor = 0.75;
  const scale = Math.min(vesselCanvas.width / vesselImg.width, vesselCanvas.height / vesselImg.height) * scaleFactor;
  const imgW = vesselImg.width * scale;
  const imgH = vesselImg.height * scale;
  const imgX = (vesselCanvas.width - imgW) / 2;
  const imgY = (vesselCanvas.height - imgH) / 2;

  // Draw vessel image
  vesselCtx.drawImage(vesselImg, imgX, imgY, imgW, imgH);

  const centerX = vesselCanvas.width / 2;
  const centerY = vesselCanvas.height / 2;
  const radius = Math.min(imgW, imgH) / 2;

  // --- Draw blockage shadows ---
  const rows = Array.from(zonesBody.querySelectorAll('tr'));
  rows.forEach((row, idx) => {
    const start = parseFloat(row.cells[0].querySelector("input").value);
    const stop = parseFloat(row.cells[1].querySelector("input").value);
    if (isNaN(start) || isNaN(stop)) return;

    const startRad = (start - 90) * Math.PI / 180; // rotate: 0° rel at top
    const stopRad  = (stop - 90) * Math.PI / 180;

    vesselCtx.beginPath();
    vesselCtx.moveTo(centerX, centerY);
    vesselCtx.arc(centerX, centerY, radius, startRad, stopRad, false);
    vesselCtx.closePath();

    vesselCtx.fillStyle = zoneColors[idx % zoneColors.length];
    vesselCtx.fill();
  });

  // --- Draw REL direction line ---
  const angleRad = (rel - 90) * Math.PI / 180;
  const endX = centerX + radius * Math.cos(angleRad);
  const endY = centerY + radius * Math.sin(angleRad);

  vesselCtx.beginPath();
  vesselCtx.moveTo(centerX, centerY);
  vesselCtx.lineTo(endX, endY);
  vesselCtx.strokeStyle = "red";
  vesselCtx.lineWidth = 3;
  vesselCtx.stroke();
}

    function updateAll() {
      const { lat, lon, satLon, heading } = getLatLon();
      const { az, el } = calcAzEl(lat, lon, satLon);
      azVal.textContent = 'AZ=' + formatNumber(az);
      const rel = ((az - heading) + 360) % 360;
      relVal.textContent = 'REL=' + formatNumber(rel);
	  // Check if REL is in any blockage zone
const blockZones = checkBlockingZones(rel);
const relBlockMsg = document.getElementById("relBlockMsg");

if (blockZones) {
  // Show first matching zone only (or modify to show multiple)
  const zone = blockZones[0];
  relBlockMsg.textContent = `Blockage area #${zone.index}`;
  relBlockMsg.style.color = zoneColors[(zone.index - 1) % zoneColors.length];
} else {
  relBlockMsg.textContent = "";
}

	  
      if (vesselImg.complete) {
        drawVesselWithREL(rel);
      } else {
        vesselImg.onload = () => drawVesselWithREL(rel);
      }
      if (el < MIN_ELEVATION) {
        elVal.innerHTML = `EL=<span style="color:red;">${formatNumber(el)} (Out of Range)</span>`;
      } else {
        elVal.textContent = 'EL=' + formatNumber(el);
      }
      const step = 0.5;
      let visibleLons = [];
      for (let lonSat = -180; lonSat <= 180; lonSat += step) {
        const { el: testEl } = calcAzEl(lat, lon, lonSat);
        if (testEl > MIN_ELEVATION) visibleLons.push(lonSat);
      }
      if (visibleLons.length > 0) {
        const minLonRaw = Math.min(...visibleLons);
        const maxLonRaw = Math.max(...visibleLons);
        const minLon = formatLonEW(minLonRaw);
        const maxLon = formatLonEW(maxLonRaw);
        document.getElementById("visibleRange").innerHTML =
          `Visible range (EL > ${MIN_ELEVATION}):<br>${minLon} to ${maxLon}`;
      } else {
        document.getElementById("visibleRange").innerHTML =
          `No satellites visible above horizon`;
      }
      copyBtn.disabled = false;
      pdfBtn.disabled = false;
      computeSatRangesAndRender();
      drawElGraph(lat, lon);
    }
    async function getAndShowLocation() {
      if (!('geolocation' in navigator)) {
        alert("Geolocation not supported.");
        return;
      }
      const opts = { enableHighAccuracy: true, maximumAge: 0, timeout: 20000 };
      return new Promise(resolve => {
        navigator.geolocation.getCurrentPosition(pos => {
          const c = pos.coords;
          latEl.value = formatNumber(Math.abs(c.latitude));
          latDir.value = c.latitude >= 0 ? "N" : "S";
          lonEl.value = formatNumber(Math.abs(c.longitude));
          lonDir.value = c.longitude >= 0 ? "E" : "W";
          updateAll();
          resolve();
        }, err => {
          alert('Location error: ' + err.message);
          resolve();
        }, opts);
      });
    }
    refreshBtn.addEventListener("click", () => getAndShowLocation());
    copyBtn.addEventListener("click", () => {
      const { lat, lon, satLon, heading } = getLatLon();
      const latText = formatNumber(Math.abs(lat)) + "°" + (lat >= 0 ? "N" : "S");
      const lonText = formatNumber(Math.abs(lon)) + "°" + (lon >= 0 ? "E" : "W");
      const satLonText = formatLonEW(satLon);
      let text = `Lat=${latText}\nLon=${lonText}\nSatLon=${satLonText}\nHeading=${heading}\n\n`;
      const visibleRangeEl = document.getElementById("visibleRange");
      if (visibleRangeEl && visibleRangeEl.textContent.trim() !== "") {
        text += visibleRangeEl.textContent + "\n\n";
      }
      const rows = Array.from(zonesBody.querySelectorAll("tr"));
      if (rows.length > 0) {
        text += "Blockage Zones:\n";
        rows.forEach((row, idx) => {
          const start = row.cells[0].querySelector("input").value;
          const stop = row.cells[1].querySelector("input").value;
          text += `  Zone ${idx + 1}: ${start}°–${stop}°\n`;
        });
      }
      const ranges = satRangesList.innerText.trim();
      if (ranges !== "") {
        text += "Blocking ranges:\n" + ranges + "\n";
      }
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.textContent = "Copied!";
        setTimeout(() => copyBtn.textContent = "Copy", 1000);
      });
    });
    pdfBtn.addEventListener("click", () => {
      const { lat, lon } = getLatLon();
      drawElGraph(lat, lon);
      const cardElement = document.querySelector(".card");
      if (!cardElement) {
        console.error("Main card element not found.");
        return;
      }
      const opt = {
        margin: [10, 10, 10, 10],
        filename: 'Satellite_Look_Angle.pdf',
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2, useCORS: true },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
      };
      html2pdf().set(opt).from(cardElement).save();
    });
    [latEl, lonEl, satLonEl].forEach(inp => {
      inp.addEventListener("blur", () => {
        normalizeInput(inp, 180);
        updateAll();
      });
      inp.addEventListener("input", updateAll);
      inp.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
    });
    headingEl.addEventListener("blur", () => {
      normalizeInput(headingEl, 360);
      updateAll();
    });
    headingEl.addEventListener("input", updateAll);
    headingEl.addEventListener("focus", e => setTimeout(() => e.target.select(), 0));
    [latDir, lonDir, satLonDir].forEach(sel => sel.addEventListener("change", updateAll));
    function computeSatRangesForZone(startAZ, stopAZ, lat, lon, heading, step = 1) {
      const start = (startAZ + 360) % 360;
      const stop = (stopAZ + 360) % 360;
      const segments = [];
      let inside = false;
      let segStart = null;
      const nSteps = Math.round((360 / step));
      for (let i = 0; i <= nSteps; i++) {
        const satLon = -180 + i * step;
        const { az, el } = calcAzEl(lat, lon, satLon);
        if (el < 0) {
          if (inside) {
            const endEstimate = refineBoundary(segStart, satLon - step, lat, lon, heading, start, stop, step);
            segments.push([segStart, endEstimate]);
            inside = false;
            segStart = null;
          }
          continue;
        }
        const rel = ((az - heading) + 360) % 360;
        let inZone = false;
        if (start <= stop) {
          inZone = (rel >= start && rel <= stop);
        } else {
          inZone = (rel >= start || rel <= stop);
        }
        if (inZone && !inside) {
          const entry = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step, true);
          segStart = entry;
          inside = true;
        } else if (!inZone && inside) {
          const exit = refineBoundary(satLon - step, satLon, lat, lon, heading, start, stop, step);
          segments.push([segStart, exit]);
          inside = false;
          segStart = null;
        }
      }
      if (inside) {
        segments.push([segStart, 180]);
      }
      console.debug('computeSatRangesForZone', { startAZ, stopAZ, segments });
      return segments;
    }
    function refineBoundary(a, b, lat, lon, heading, start, stop, coarseStep, findEntry = false) {
      if (a < -180) a = -180;
      if (b > 180) b = 180;
      const subSteps = 10;
      let best = findEntry ? b : a;
      for (let k = 0; k <= subSteps; k++) {
        const t = k / subSteps;
        const satLon = a + (b - a) * t;
        const { az, el } = calcAzEl(lat, lon, satLon);
        if (el < 0) continue;
        const rel = ((az - heading) + 360) % 360;
        let inZone = false;
        if (start <= stop) inZone = (rel >= start && rel <= stop);
        else inZone = (rel >= start || rel <= stop);
        if (inZone) {
          if (findEntry) {
            best = Math.min(best, satLon);
          } else {
            best = Math.max(best, satLon);
          }
        }
      }
      return Math.round(best * 100) / 100;
    }
    function computeSatRangesAndRender() {
      const { lat, lon, heading } = getLatLon();
      const rows = Array.from(zonesBody.querySelectorAll('tr'));
      if (rows.length === 0) {
        satRangesList.innerHTML = "<i>(no Blockage Zones)</i>";
        return;
      }
      const sampleStep = 0.5;
      const outPieces = [];
      rows.forEach((row, idx) => {
        const start = parseFloat(row.cells[0].querySelector("input").value);
        const stop = parseFloat(row.cells[1].querySelector("input").value);
        if (isNaN(start) || isNaN(stop)) return;
        let ranges = computeSatRangesForZone(start, stop, lat, lon, heading, sampleStep);
        const west = [], east = [];
        ranges.forEach(([a, b]) => {
          let A = ((a + 540) % 360) - 180;
          let B = ((b + 540) % 360) - 180;
          if (A > B) {
            const tmp = A;
            A = B;
            B = tmp;
          }
          if (B <= 0) {
            const lo = Math.abs(B);
            const hi = Math.abs(A);
            west.push([lo, hi]);
          } else if (A >= 0) {
            east.push([A, B]);
          } else {
            west.push([Math.abs(A), 180]);
            east.push([0, B]);
          }
        });
        function mergeIntervals(list) {
          if (list.length <= 1) return list;
          list.sort((a, b) => a[0] - b[0]);
          const merged = [list[0].slice()];
          for (let i = 1; i < list.length; i++) {
            const [s, e] = list[i];
            const last = merged[merged.length - 1];
            if (s <= last[1] + 0.5) {
              last[1] = Math.max(last[1], e);
            } else merged.push([s, e]);
          }
          return merged;
        }
        const mergedWest = mergeIntervals(west);
        const mergedEast = mergeIntervals(east);
        const parts = [];
        mergedWest.forEach(([lo, hi]) => {
          if (hi < lo) {
            const t = lo;
            lo = hi;
            hi = t;
          }
          parts.push(`${formatNumber(lo)}°W to ${formatNumber(hi)}°W`);
        });
        mergedEast.forEach(([lo, hi]) => {
          if (hi < lo) {
            const t = lo;
            lo = hi;
            hi = t;
          }
          parts.push(`${formatNumber(lo)}°E to ${formatNumber(hi)}°E`);
        });
        if (parts.length === 0) {
          outPieces.push(`<div class="zone-range"><span class="color" style="background:${zoneColors[idx % zoneColors.length].replace("0.25","1.0")}"></span> Zone ${idx + 1} No blockage for visible Satellites</div>`);
        } else {
          outPieces.push(`<div class="zone-range"><span class="color" style="background:${zoneColors[idx % zoneColors.length].replace("0.25","1.0")}"></span> Zone ${idx + 1} Blockage range:  ${parts.join(', ')}</div>`);
        }
      });
	  
	  
	  
	  
	  if (outPieces.length === 0) {
  satRangesList.innerHTML = "<i>(no Blockage Zones)</i>";
  satRangesList.classList.remove("two-col");
} else {
  satRangesList.innerHTML = outPieces.join("");
  if (outPieces.length > 1) {
    satRangesList.classList.add("two-col");
  } else {
    satRangesList.classList.remove("two-col");
  }
}

	  
	  
    }
    function setupKeyboardNavigation() {
      const focusable = Array.from(document.querySelectorAll("input, select"));
      focusable.forEach((el, idx) => {
        el.onkeydown = (e) => {
          let newIndex = null;
          if (e.key === "Enter" && el.tagName !== "SELECT") {
            e.preventDefault();
            newIndex = e.shiftKey ? idx - 1 : idx + 1;
          }
          if (el.tagName !== "SELECT") {
            if (e.key === "ArrowRight" || e.key === "ArrowDown") {
              e.preventDefault();
              newIndex = idx + 1;
            }
            if (e.key === "ArrowLeft" || e.key === "ArrowUp") {
              e.preventDefault();
              newIndex = idx - 1;
            }
          }
          if (newIndex !== null) {
            if (newIndex < 0) newIndex = focusable.length - 1;
            if (newIndex >= focusable.length) newIndex = 0;
            focusable[newIndex].focus();
          }
        };
      });
    }
    window.addEventListener('DOMContentLoaded', () => {
      setupKeyboardNavigation();
      updateAll();
    });
    window.addEventListener("error", function(event) {
      let msg = document.getElementById("errorBox");
      if (!msg) {
        msg = document.createElement("div");
        msg.id = "errorBox";
        msg.style.background = "#fee";
        msg.style.color = "red";
        msg.style.padding = "8px";
        msg.style.border = "1px solid red";
        msg.style.margin = "10px 0";
        msg.style.fontWeight = "bold";
        document.body.prepend(msg);
      }
      msg.textContent = "⚠️ Error: " + event.message + " (line " + event.lineno + ")";
    });
    window.addEventListener("resize", updateAll);
  </script>
  
</body>
</html>
